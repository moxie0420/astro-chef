---
import { genMd } from "@lib/markdown";

interface Props {
  name?: string;
  body: string | null;
  editing?: boolean;
}

const { body, editing = false, name = "body" } = Astro.props;
---

{
  editing ? (
    <div
      is="markdown-component"
      class="grid grid-row md:grid-cols-2  gap-1 p-1 border rounded-md bg-overlay selection:outline selection:outline-pine max-w-screen-xl mx-auto overflow-scroll h-screen"
    >
      <textarea
        id="text"
        name={name}
        class="prose resize prose-rosePine bg-inherit border-rosePine-highlightHigh bg-overlay w-full"
        set:text={body}
      />
      <div
        id="preview"
        class="prose border-none resize prose-rosePine border-rosePine-highlightHigh bg-overlay"
      />
    </div>
  ) : (
    <article
      set:html={await genMd(body || "")}
      class="p-2 pt-10 mx-auto prose-sm prose text-center md:prose-lg 2xl:prose-2xl prose-rosePine bg-overlay rounded-md my-2"
    />
  )
}

<script>
  import { marked, type RendererObject } from "marked";
  import DOMPurify from "dompurify";

  class Markdown extends HTMLElement {
    renderer: RendererObject = {
      image({ href, text }) {
        return `<img src="/api/image?path=${href}" alt="${text}" />`;
      },
    };

    async genCleanHtml(md: string) {
      return DOMPurify.sanitize(await marked.parse(md));
    }
    async connectedCallback() {
      const input = this.querySelector("#text") as HTMLTextAreaElement;
      const preview = this.querySelector("#preview");

      marked.use({ renderer: this.renderer, async: true, gfm: true });

      if (preview && input) {
        preview.innerHTML = await this.genCleanHtml(input.value);

        input.addEventListener("change", async () => {
          preview.innerHTML = await this.genCleanHtml(input.value);
        });
      }
    }
  }

  customElements.define("markdown-component", Markdown);
</script>
